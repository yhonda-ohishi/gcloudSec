#!/bin/bash
#
# secrets - GitHub clone風 Secret Manager CLI
# 複数プロジェクトの .env / .dev.vars を一元管理
#

set -e

# === 設定 ===
# 環境変数または設定ファイルから読み込み
CONFIG_FILE="${HOME}/.secrets-manager.conf"
if [[ -f "$CONFIG_FILE" ]]; then
    source "$CONFIG_FILE"
fi

CENTRAL_PROJECT="${SECRETS_CENTRAL_PROJECT:-}"
SEPARATOR="_"  # フォルダとシークレット名の区切り文字

# === カラー出力 ===
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# === ヘルパー関数 ===
log_info() { echo -e "${BLUE}[INFO]${NC} $1"; }
log_success() { echo -e "${GREEN}[OK]${NC} $1"; }
log_warn() { echo -e "${YELLOW}[WARN]${NC} $1"; }
log_error() { echo -e "${RED}[ERROR]${NC} $1" >&2; }

check_project() {
    if [[ -z "$CENTRAL_PROJECT" ]]; then
        log_error "SECRETS_CENTRAL_PROJECT が設定されていません"
        echo ""
        echo "設定方法:"
        echo "  export SECRETS_CENTRAL_PROJECT=your-project-id"
        echo ""
        echo "または ~/.secrets-manager.conf に以下を記載:"
        echo "  SECRETS_CENTRAL_PROJECT=your-project-id"
        exit 1
    fi
}

# フォルダ名とシークレット名を結合
make_secret_name() {
    local folder="$1"
    local key="$2"
    echo "${folder}${SEPARATOR}${key}"
}

# シークレット名からフォルダ名を抽出
get_folder_from_secret() {
    local secret_name="$1"
    echo "$secret_name" | cut -d"$SEPARATOR" -f1
}

# シークレット名からキー名を抽出
get_key_from_secret() {
    local secret_name="$1"
    echo "$secret_name" | cut -d"$SEPARATOR" -f2-
}

# === コマンド: init ===
cmd_init() {
    echo "Secret Manager 初期設定"
    echo ""

    read -p "中央管理用 GCP プロジェクトID: " project_id

    if [[ -z "$project_id" ]]; then
        log_error "プロジェクトIDを入力してください"
        exit 1
    fi

    # Secret Manager API 有効化確認
    log_info "Secret Manager API を有効化中..."
    gcloud services enable secretmanager.googleapis.com --project="$project_id" 2>/dev/null || true

    # 設定ファイル作成
    echo "SECRETS_CENTRAL_PROJECT=$project_id" > "$CONFIG_FILE"
    log_success "設定を保存しました: $CONFIG_FILE"

    export CENTRAL_PROJECT="$project_id"
    log_success "初期設定完了: $project_id"
}

# === コマンド: push ===
cmd_push() {
    local folder="$1"
    local env_file="$2"

    if [[ -z "$folder" ]]; then
        log_error "フォルダ名を指定してください"
        echo "使用法: secrets push <folder> [.env file]"
        exit 1
    fi

    # .env ファイルの自動検出
    if [[ -z "$env_file" ]]; then
        if [[ -f ".dev.vars" ]]; then
            env_file=".dev.vars"
        elif [[ -f ".env" ]]; then
            env_file=".env"
        elif [[ -f ".env.local" ]]; then
            env_file=".env.local"
        else
            log_error ".env または .dev.vars ファイルが見つかりません"
            exit 1
        fi
    fi

    if [[ ! -f "$env_file" ]]; then
        log_error "ファイルが見つかりません: $env_file"
        exit 1
    fi

    log_info "アップロード: $env_file → $folder/"

    local count=0
    while IFS= read -r line || [[ -n "$line" ]]; do
        # 空行とコメント行をスキップ
        [[ -z "$line" || "$line" =~ ^[[:space:]]*# ]] && continue

        # KEY=VALUE を分離
        if [[ "$line" =~ ^([A-Za-z_][A-Za-z0-9_]*)=(.*)$ ]]; then
            local key="${BASH_REMATCH[1]}"
            local value="${BASH_REMATCH[2]}"

            # クォートを除去
            value="${value#\"}"
            value="${value%\"}"
            value="${value#\'}"
            value="${value%\'}"

            local secret_name=$(make_secret_name "$folder" "$key")

            # シークレットが存在するか確認
            if gcloud secrets describe "$secret_name" --project="$CENTRAL_PROJECT" &>/dev/null; then
                # 新しいバージョンを追加
                echo -n "$value" | gcloud secrets versions add "$secret_name" \
                    --data-file=- \
                    --project="$CENTRAL_PROJECT" \
                    --quiet
                log_success "  更新: $key"
            else
                # 新規作成
                gcloud secrets create "$secret_name" \
                    --replication-policy="automatic" \
                    --labels="folder=$folder" \
                    --project="$CENTRAL_PROJECT" \
                    --quiet

                echo -n "$value" | gcloud secrets versions add "$secret_name" \
                    --data-file=- \
                    --project="$CENTRAL_PROJECT" \
                    --quiet
                log_success "  作成: $key"
            fi

            ((count++))
        fi
    done < "$env_file"

    log_success "完了: ${count}件のシークレットをアップロードしました"
}

# === コマンド: pull ===
cmd_pull() {
    local folder="$1"
    local output_file="$2"

    if [[ -z "$folder" ]]; then
        log_error "フォルダ名を指定してください"
        echo "使用法: secrets pull <folder> [output file]"
        exit 1
    fi

    # フォルダに属するシークレット一覧を取得
    local secrets=$(gcloud secrets list \
        --project="$CENTRAL_PROJECT" \
        --filter="labels.folder=$folder" \
        --format="value(name)" 2>/dev/null)

    if [[ -z "$secrets" ]]; then
        log_warn "フォルダ '$folder' にシークレットが見つかりません"
        exit 0
    fi

    local output=""

    while IFS= read -r secret_name; do
        [[ -z "$secret_name" ]] && continue

        local key=$(get_key_from_secret "$secret_name")
        local value=$(gcloud secrets versions access latest \
            --secret="$secret_name" \
            --project="$CENTRAL_PROJECT" 2>/dev/null)

        output+="${key}=${value}"$'\n'
    done <<< "$secrets"

    # 出力
    if [[ -n "$output_file" ]]; then
        echo -n "$output" > "$output_file"
        log_success "保存: $output_file"
    else
        echo -n "$output"
    fi
}

# === コマンド: list ===
cmd_list() {
    local folder="$1"

    if [[ -z "$folder" ]]; then
        # フォルダ一覧を表示
        log_info "フォルダ一覧:"
        gcloud secrets list \
            --project="$CENTRAL_PROJECT" \
            --format="value(labels.folder)" 2>/dev/null | sort -u | while read -r f; do
            [[ -n "$f" ]] && echo "  $f/"
        done
    else
        # フォルダ内のシークレット一覧
        log_info "フォルダ '$folder' のシークレット:"
        gcloud secrets list \
            --project="$CENTRAL_PROJECT" \
            --filter="labels.folder=$folder" \
            --format="value(name)" 2>/dev/null | while read -r secret_name; do
            local key=$(get_key_from_secret "$secret_name")
            echo "  $key"
        done
    fi
}

# === コマンド: delete ===
cmd_delete() {
    local folder="$1"
    local key="$2"

    if [[ -z "$folder" ]]; then
        log_error "フォルダ名を指定してください"
        echo "使用法: secrets delete <folder> [key]"
        exit 1
    fi

    if [[ -z "$key" ]]; then
        # フォルダ全体を削除
        read -p "フォルダ '$folder' の全シークレットを削除しますか? [y/N]: " confirm
        if [[ "$confirm" != "y" && "$confirm" != "Y" ]]; then
            log_info "キャンセルしました"
            exit 0
        fi

        gcloud secrets list \
            --project="$CENTRAL_PROJECT" \
            --filter="labels.folder=$folder" \
            --format="value(name)" 2>/dev/null | while read -r secret_name; do
            gcloud secrets delete "$secret_name" \
                --project="$CENTRAL_PROJECT" \
                --quiet
            log_success "削除: $secret_name"
        done
    else
        # 特定のキーを削除
        local secret_name=$(make_secret_name "$folder" "$key")
        gcloud secrets delete "$secret_name" \
            --project="$CENTRAL_PROJECT" \
            --quiet
        log_success "削除: $folder/$key"
    fi
}

# === コマンド: clone ===
cmd_clone() {
    local folder="$1"
    local target_dir="${2:-.}"

    if [[ -z "$folder" ]]; then
        log_error "フォルダ名を指定してください"
        echo "使用法: secrets clone <folder> [target directory]"
        exit 1
    fi

    log_info "クローン: $folder → $target_dir/.env"
    cmd_pull "$folder" "$target_dir/.env"
}

# === コマンド: diff ===
cmd_diff() {
    local folder="$1"
    local env_file="$2"

    if [[ -z "$folder" ]]; then
        log_error "フォルダ名を指定してください"
        exit 1
    fi

    # .env ファイルの自動検出
    if [[ -z "$env_file" ]]; then
        if [[ -f ".dev.vars" ]]; then
            env_file=".dev.vars"
        elif [[ -f ".env" ]]; then
            env_file=".env"
        else
            log_error ".env または .dev.vars ファイルが見つかりません"
            exit 1
        fi
    fi

    log_info "比較: ローカル ($env_file) vs リモート ($folder)"

    local remote_content=$(cmd_pull "$folder" 2>/dev/null | sort)
    local local_content=$(grep -v '^#' "$env_file" | grep -v '^$' | sort)

    diff <(echo "$local_content") <(echo "$remote_content") || true
}

# === ヘルプ ===
show_help() {
    cat << 'EOF'
secrets - GitHub clone風 Secret Manager CLI

使用法:
  secrets <command> [arguments]

コマンド:
  init                      初期設定（中央プロジェクトの設定）
  push <folder> [file]      .env/.dev.vars をアップロード
  pull <folder> [file]      シークレットを .env 形式で取得
  clone <folder> [dir]      git clone 風に .env をダウンロード
  list [folder]             フォルダ/シークレット一覧
  delete <folder> [key]     シークレット削除
  diff <folder> [file]      ローカルとリモートの差分表示

例:
  secrets init                          # 初期設定
  secrets push my-project               # カレントの .env をアップロード
  secrets push my-project .dev.vars     # .dev.vars をアップロード
  secrets pull my-project               # 標準出力に出力
  secrets pull my-project .env          # .env ファイルに保存
  secrets clone my-project              # .env としてダウンロード
  secrets list                          # フォルダ一覧
  secrets list my-project               # my-project 内のキー一覧
  secrets diff my-project               # ローカルとの差分

設定:
  環境変数 SECRETS_CENTRAL_PROJECT または
  ~/.secrets-manager.conf に SECRETS_CENTRAL_PROJECT=xxx を設定
EOF
}

# === メイン ===
main() {
    local command="${1:-help}"
    shift || true

    case "$command" in
        init)
            cmd_init "$@"
            ;;
        push)
            check_project
            cmd_push "$@"
            ;;
        pull)
            check_project
            cmd_pull "$@"
            ;;
        clone)
            check_project
            cmd_clone "$@"
            ;;
        list|ls)
            check_project
            cmd_list "$@"
            ;;
        delete|rm)
            check_project
            cmd_delete "$@"
            ;;
        diff)
            check_project
            cmd_diff "$@"
            ;;
        help|--help|-h)
            show_help
            ;;
        *)
            log_error "不明なコマンド: $command"
            show_help
            exit 1
            ;;
    esac
}

main "$@"
